### Contest 1

## A_Octal

Почему настоящие программисты путают католическое Рождестово и Halloween?

Потому что 25 DEC = 31 OCT.

Дано целое число X в десятичной системе счисления. Выведите запись числа X в восьмеричной системе счисления.

Ограничения: 0 ≤ X ≤ 1000000000000000000

## B_triple

Дано целое число T в троичной системе счисления. Выведите запись числа T в десятичной системе счисления.

Ограничения: 0 ≤ T ≤ 6 * 10^10

## C_sum

На стандартном потоке ввода подается последовательно вещественное число x и целое число в 16-ричной записи y. Единственным аргументов программы является целое число z в 27-ричной системе исчисления. Необходимо вывести вычислить значение x+y+z и вывести его на стандартный поток вывода с точностью до 3-го знака после точки.

## D_big_num_bin_sum

Напишите программу, которая суммирует большие натуральные числа, заданные в двоичной системе счисления.

Формат ввода

Две строки, содержащие двоичные записи неотрицательных целых чисел a и b. Количество цифр в каждой записи не более 1000.

Формат вывода

Двоичная запись числа a+b.

## E_hexen

Переведите число, записанное в шестнадцатиричной системе счисления, в двоичную.

Входные данные: неотрицательное шестнадцатиричное число, содержащее не более 1000000 цифр (0123456789ABCDEF).

Единственная строка выходных данных должна содержать последовательность 0 и 1, образующих двоичную запись числа, полученного на входе. Лидирующих нулей быть не должно.

## F_decimal

Для вычисления очень больших целых чисел создали структуру Decimal.

```c 
#define N 100

struct _Decimal {
  char a[N];                // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
  unsigned int n;           // наибольшая степень десяти
};
typedef struct _Decimal Decimal;

Decimal zero = {{0}, 0};    // представление 0 в виде структуры
```

Реализуйте функцию сложения чисел a и b, которая возвращает сумму чисел. Проверьте функцию.

```c 
Decimal add(Decimal a, Decimal b);
```

В проверяющую систему посылать только реализацию требуемой функции.

## G_longN

Дана строка цифр длинной не более 200 символов. В начале строки может стоять не цифровой символ: "+" или "-". Если строка начинается с цифры или символа "+" -- это положительное число. Еcли строка начинается с символа "-" -- число отрицательное.

Для хранения и представления числа используется структура:

```c
typedef struct {
  char *dig;	// массив для хранения числа:
                // a[0] * 100^0 + a[1] * 100^1 + .. + a[n - 1] * 100^(n-1)
  int n;        // размер числа в разрядах
  char sign;	// знак числа
}LongN;
```

Число записывается по основанию 100. При этом младшие разряды числа записываются в начало массива, а старшие - в конец

Для положительных чисел и нуля, знак (sign) записывается как 0, для отрицательных -- как 1.

Размер числа (n) записывается как количество разрядов числа по основанию 100. Например, для числа 12345, n=3;

Написать функцию

```c
LongN getLongN(char* s);
```

которая преобразует данную строку в длинное число.

## H_setun

Уникальная и необычно дешёвая для своего времени ЭВМ "Сетунь" работала в уравновешенной троичной системе счисления.

В уравновешенной троичной системе счисления используется основание 3 и три цифры: 0, 1 и -1. Цифру -1 будем обозначать знаком $. Достоинство уравновешенной троичной системы счисления: простота хранения отрицательных чисел и удобство нахождения числа, противоположному данному.

Дано два числа, записанных в уравновешенной троичной системе счисления. Выведите их сумму без лидирующих нулей в этой же системе счисления. Длины входных чисел не превосходят 1000 символов.

## I_any

Напишите программу, переводящую запись числа между двумя произвольными системами счисления.

На вход программа получает три величины: n, A, k, где n и k – натуральные числа от 2 до 36: основания системы счисления, A – число, записанное в системе счисления с основанием n, 0 ≤ A < 2^31.

Необходимо вывести значение A в системе счисления с основанием k без лидирующих нулей.

## J_rational

Дано неотрицательное число, записанное в виде двоичной дроби: запись содержит только цифры 0 и 1 и, возможно, точку. Запись числа содержит не более 30 символов. Переведите это значение в величину типа `double` и выведите результат с точностью не менее 12 знаков (`printf ("%.12lf", x);` или для cout инструкция `cout.precision(12);`).

## K_rome2arabic

Из римских в арабские
Ограничение по времени работы программы: 1 секунда.
Ограничение по памяти: 32 мегабайта.
Ввод из стандартного потока ввода (с клавиатуры).
Вывод в стандартный поток вывода (на экран).

Переведите число из римской системы счисления в арабскую.

Входные данные:
Вводится целое число N (1 ≤ N < 4000) в римской системе счисления. Римские символы записаны заглавными латинскими буквами IVXLCDM.

Выходные данные:
Вывести число в десятичной системе счисления, используя арабские цифры.

## L_Q

Рассматриваются трёхзначные числа, записанные в x-ричной системе счисления. Найти наибольшее такое число, которое при возведении в квадрат оканчивается на исходное число. Ответ записать в десятичной системе счисления.

Входные данные:
Единственнное натуральное число - основание системы счисления (в десятичной системе счисления) 50 ≤ x ≤ 80.

Выходные данные:
Единственное натуральное число - ответ (в десятичной системе счисления).

## M_base

Дано несколько равенств вида X*Y=Z или X+Y=Z. Но неизвестно основание системы счисления, в котором они записаны.
Проверьте, существует ли основание системы счисления, в котором все данные равенства верны (являются тождествами).

Входные данные:
В первой строке дано количество равенств N, N — натуральное число от 1 до 1000 включительно. Затем в последующих N строках даны равенства в формате

```c
X*Y=Z 
X+Y=Z        
```

где все X, Y и Z — записи положительных целых чисел, то есть слова в алфавите {0,1, .. 9, a, ..z}. Латинские буквы от а до z соответствуют цифрам от 10 до 35. Количество цифр меньше 11. В случае, если основание восстанавливается однозначно, все числа в примерах не превосходят 2^64-1.

Выходные данные:
Вывести основание используемой во всех данных примерах системы счисления, если такая существует и восстанавливается однозначно. Выведите "0", если такой системы не существует, или "-1", если система счисления не восстанавливается однозначно по данным примерам. Запись основания необходимо вывести в десятичной системе счисления.

## N_i

Rome
You are given a string consisting of characters with ASCII codes from 34 to 126, inclusive. Capital and lowercase letters I, i, V, v, X, x, L, l, C, c, D, d, M, m in this string are considered as Roman digits; lowercase and uppercase letters are considered the same. Your task is to make up the longest possible number in the Roman numeral system from these characters (given letters can be rearranged arbitrarily). If several such numbers exist, choose the largest one.

The rules in the Roman numeral system are the following. Mentioned letters I, V, X, L, C, D and M (Roman digits) correspond to numbers 1, 5, 10, 50, 100, 500 and 1000 respectively. A number in the Roman numeral system cannot have more than three identical letters in a row. Each of the characters V, L, D can appear at most once. Letters I, X, C can be put before letters X, C and M to make up 9, 90 and 900, or before letters V, L and D to make up 4, 40 and 400 respectively. IX and IV cannot be followed by anything else, XL and XC can be followed only by V or I, CD and CM only by L, X, V or I. For example, IVII is not a correct Roman numeral. In other cases, one digit put after another means just the sum of the digits. IV, XC, . . . Lastly, a smaller digit must be put after a bigger or identical one (here combinations are considered like digits). So representation of a number in the Roman numeral system is unique.

Input:

On the first line of input file, there is a non-empty string consisting of characters with ASCII codes from 34 to 126, inclusive. The string length does not exceed 100 000 characters.

Output:

Please output the largest of the longest possible numbers in the Roman numeral system which can be formed from the given string. Denote all Roman numerals by capital letters.

## O_drob

В рамках программы импортозамещения начата разработка обучающей системы "Задачник Отечественного Школьника". Вам поручено реализовать модуль, отвечающий за сложение рациональных чисел. На вход подаются два неотрицательных рациональных числа A и B, записанные в виде десятичных дробей. Требуется вывести их сумму A+B, записанную аналогичным образом, но в соответствии с правилами записи десятичных дробей.

Входные данные:

Первые две строки входного файла содержат A и B. Каждое из чисел представляет собой десятичную дробь в виде X.Y, X.(Z) или X.Y(Z), где Х — целая часть дроби, Y — непериодическая часть дроби, Z — периодическая часть. Общее количество цифр в записи каждой дроби не превосходит восьми. Ведущие нули в записи целой части дроби отсутствуют (если дробь меньше единицы, выводится ровно один нуль). Оба числа A и B неотрицательны.

Выходные данные:

Выведите одну строку — сумму, записанную в виде десятичной дроби без дополнительных ведущих нулей. При этом должны соблюдаться обычные правила записи десятичных дробей:

- Длина записи должна быть наименьшей из всех возможных;
- Запись (9...9) не допускается (то есть вместо 0.1(9) требуется выводить 0.2);
- Если в результате получается целое число, выводить десятичную точку не требуется.