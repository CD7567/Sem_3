## Contest_3

### A_cpu

Рассмотрим 8-битный процессор, который может обрабатывать элементарные команды, получая их на вход в виде кодов.

Числа считаются беззнаковыми.

HLT (0) - останов

ADD (1) - сложение

SUB (2) - вычитание

У этих команд аргументы - 2 номера регистров, результат записывается в первый из них.

MOV (3) - присвоение

Аргументы - номер регистра и целое число, которое в него заносится.

IR (4) - вывести все регистры

Регистры и их номера: A (5), B (6), C (7), D (8).

До начала работы программы в регистрах нули.

К сожалению, некоторые чипы получаются с дефектами. У них меньше регистров. В таком случае через параметр -D (аналог #define) при компиляции программе передаётся константа REGISTERS. В таком случае допустимы лишь некоторые из них. Если встретился регистр, которого у данного дефектного чипа нет, то нужно завершить работу эмулятора, выведя число -1, что означает недопустимый номер регистра. Например, если константа REGISTERS определена и её значение равно 2, то допустимы только регистры A и B с кодами 5 и 6 соответственно, а команда 1 6 7 (прибавить к B значение регистра С) приведёт к ошибке Illegal Instruction и в данном эмуляторе нужно вывести -1.

Что будет выведено в результате работы программы?

### B_cache

The matrix has you....

Time limit: 2 секунды

Memory limit: 1 гигабайт

Рассмотрим две квадратные матрицы А и В размера n. A[i][j]=НОД(i+1, j+1), B[i][j]=НОД(n-i+1, n-j+1), где НОД(x,y) - наибольший общий делитель чисел x и y. Выведите количество элементов произведения матриц АВ, которые делятся на заданное число d.

Вход: целые числа n, d

Ограничения: 0 ≤ n ≤ 1024.

Ограничения: 1 ≤ d ≤ 100.

### C_neo

Нео попал к Архитектору, и тот рассказал ему, что он уже шестой такой, так что в палате ему будет не скучно. Вот Наполеон пока единственный, зато успел поссориться со всеми санитарами. Вот если бы он был нулевым, тогда Архитектор ему поверил. Но Нео раздобыл исходный код Матрицы:

```c
struct anomaly {
  char name_of_anomaly[256];
  int number_of_anomaly;
};
```

Нео знает, что машины Матрицы little-endian. Архитектор спросил у Нео, как его зовут, а именно, вызвал у него функцию char* whatisyourname(); Нео знает, что Архитектор будет копировать из полученной по указателю строки данные в структуру, пока не встретит признак конца строки - нулевой байт. Помогите Нео убедить Архитектора, что он нулевой, а значит, самый крутой Избранный. Для этого Вам надо написать свою функцию char* whatisyourname() без ввода-вывода и main() - это всё и так есть у Архитектора. Имейте в виду: если Архитектор упадёт от нечитаемого кода с сердечным приступом или от его исполнения с Segmentation Fault'ом, то весь мир, включая Нео, исчезнет. Функция должна выделять место под имя динамически и затем возвращать указатель на него.

### D_flag

Рассмотрим 8-битный процессор, который может обрабатывать элементарные команды, получая их на вход в виде кодов.

Числа считаются беззнаковыми.

Ещё у него появился один бит - флаг нуля. Он выставляется, если результат команды равен 0. Если старший бит номера команды равен 1, то она исполняется тогда и только тогда, когда флаг нуля установлен, иначе пропускается. Флаг сбрасывается, если результат команды ненулевой.

HLT (0) - останов

ADD (1) - сложение

SUB (2) - вычитание

У этих команд аргументы - 2 номера регистров, результат записывается в первый из них.

MOV (3) - присвоение

Аргументы - номер регистра и целое число, которое в него заносится.

IR (4) - вывести все регистры

Регистры и их номера: A (5), B (6), C (7), D (8).

До начала работы программы в регистрах нули. Что будет выведено в результате работы программы?

### E_cuda

"CUDA Occupancy Calculator". CUDA — это программно-аппаратная архитектура, позволяющая использовать видеокарты корпорации nVidia для высокопараллельных вычислений в алгоритмах, никак не связанных с графикой. В этой задаче мы ограничимся описанием аппаратной архитектуры Fermi поколения видеокарт, появившегося в марте 2010 года. На смену ему в марте 2012 года пришла архитектура Kepler. Правда, в некоторых задачах видеокарты Fermi показывают лучшую производительность, чем видеокарты Kepler. Для таких задач вся надежда на следующее поколение видеокарт — Maxwell.

Основное отличие вычислений на видеокарте от вычислений на центральном процессоре состоит в следующем. На современных процессорах могут одновременно исполняться единицы или десятки физических потоков исполнения, а на видеокарте — тысячи или десятки тысяч. Один поток исполнения видеокарты довольно малопроизводителен по сравнению с одним потоком исполнения процессора. Однако, в видеокарте потоков существенно больше, чем в процессоре, поэтому для хорошо распараллеливающейся задачи решение на топовой видеокарте может работать порядка 10 раз быстрее, чем на топовом процессоре.

Для обеспечения максимальной производительности CUDA-программы программист должен внимательно следить за тем, чтобы используемые единицей запуска (ядром) ресурсы, например, количество регистров, используемых в каждом потоке, соответствовали аппаратным ограничениям. Если программное ядро будет использовать несколько больше регистров, то на одной аппаратной единице исполнения (мультипроцессоре) сможет поместиться меньше потоков исполнения, чем могло бы, и производительность от этого может страдать. Картина, конечно же, не является чёрно-белой — в отдельных случаях при менее чем 100% загруженности мультипроцессора удаётся достигать лучших результатов. Однако, это скорее исключение, так что каждый CUDA-программист должен внимательно следить за тем, как хорошо требования его программы соответствуют аппаратным возможностям.

Для того чтобы предоставить CUDA-программисту полную информацию о влиянии использования ресурсов на загруженность мультипроцессора, специалисты корпорации nVidia создали Excel-таблицу "CUDA Occupancy Calculator". В неё можно ввести параметры использования ресурсов и получить результат — отношение числа потоков, которые реально смогут быть запущены на мультипроцессоре, к максимальному числу потоков, которые могли бы быть запущены на мультипроцессоре. Точно такие же вычисления загруженности и Вам нужно будет произвести в этой задаче. Упомянутая Excel-таблица также строит графики, позволяющие понять, использование каких ресурсов можно уменьшить для увеличения загруженности мультипроцессора или использование каких ресурсов можно увеличить без ущерба для загруженности мультипроцессора. В этой задаче строить графики не потребуется.

Физической единицей исполнения является мультипроцессор. В архитектуре Fermi он способен исполнять до 1536 потоков одновременно. Заметим, что в одной видеокарте обычно содержится несколько мультипроцессоров — скажем, в GTX 580 их 16, так что общее число потоков исполнения в этой карте может достигать 24 576.

На мультипроцессоре имеется разделяемая память, которой можно использовать до 49 152 байт. Также на мультипроцессоре есть 4-байтовые регистры в количестве 32 768 штук.

Логической единицей исполнения является блок. Для каждого блока программист задаёт количество потоков, которые в рамках этого блока исполняются (для архитектуры Fermi количество потоков в блоке от 1 до 1024). Также программист определяет количество переменных, использующих разделяемую память, и, соответственно, объём разделяемой памяти, используемой одним блоком. Количество регистров, используемых блоком, обычно определяется компилятором CUDA, но в критических случаях программист может регулировать это значение с помощью ключей компиляции.

Одновременно на мультипроцессоре может исполняться целое количество блоков, для архитектуры Fermi — от 1 до 8. То есть если сделать очень маленький блок, то более 8 блоков всё равно запущено не будет, и большая часть ресурсов мультипроцессора не будет использована.

Гранулярность выделения физических потоков исполнения — 32 штуки, то есть если в блоке 225 потоков, то реально будет занято 256 физических потоков. Гранулярность выделения разделяемой памяти — 128 байт, то есть если блоку нужно использовать 513 байт разделяемой памяти, то реально на блок будет выделено 640 байт. Гранулярность выделения регистров на поток — 2 штуки, то есть если блоку нужно использовать 21 регистр, то реально будут использоваться 22, причём в том числе и для тех потоков, которые были добавлены в силу гранулярности выделения физических потоков исполнения.

Приведём пример расчёта загруженности мультипроцессора для блока со следующими характеристиками: потоков на блок 400, регистров на поток 30, разделяемой памяти на блок 10 000 байт. Для начала найдём количество реально используемых для блока потоков. Это минимальное число, не меньшее исходного числа потоков на блок, и делящееся на 32. Это 416 потоков. Один мультипроцессор может исполнять одновременно до 1536 потоков, то есть если учитывать только число потоков, то можно сказать, что мультипроцессор может запустить до трёх таких блоков.

Количество регистров, используемых одним потоком, 30, уже делится на 2 —единицу гранулярности выделения регистров на поток, поэтому это значение не корректируем. В блоке всего используется 416 × 30 = 12 480 регистров. Всего в мультипроцессоре 32 768 регистров, то есть с учётом ограничения на регистры мультипроцессор может запустить до двух блоков.

Разделяемой памяти на блок 10 000 байт, с учётом гранулярности выделения разделяемой памяти одним блоком будет использоваться 10 112 байт. Всего в мультипроцессоре её 49 152 байта, то есть с учётом количества разделяемой памяти мультипроцессор может запустить до 4 блоков.

Итого максимальным числом блоков, подходящим под ограничения по потокам, регистрам и разделяемой памяти, является 2. Отсюда легко найти загруженность мультипроцессора. Умножаем число блоков 2 на число полезных потоков в блоке 400 и делим на число максимально возможных потоков исполнения 1536. Получаем 0.5208(3). В этой задаче нужно будет округлить результат до целого числа процентов— то есть ответ будет равен 52%.

Замечание. Реальный CUDA Occupancy Calculator в приведённом примере получил бы 54%, поскольку он полагает 32 потока исполнения (варп) настолько неделимой единицей, что число "полезных" потоков в блоке считает равным не 400, а 416 — минимальному числу, большему заданного и делящемуся на 32. Для всех практических целей такое допущение вполне подходит, поскольку в хорошо оптимизированных программах число потоков в блоке, как правило, кратно 32.

Время тестирования: 1 секунда на один тест на Intel Core2 2.66 ГГц.

В первой строке входного файла cuda.in находятся три числа через пробел: количество потоков на блок (от 1 до 1024), количество регистров на поток (от 1 до 63) и количество разделяемой памяти на блок в байтах (от 0 до 49152).

Выведите в выходной файл cuda.out одно целое число — процент полезной загруженности мультипроцессора, округленный к ближайшему целому.

### F_simple_page

Страничная организация памяти
В вычислительной системе со страничной организацией памяти из 32-х бит адреса старшие 6 его бит отводятся для номера страницы. По данному логическому адресу памяти вычислите соответствующий физический адрес.

Ввод

Целое число N - количество страниц. Далее N 16-ричных чисел - начальные адреса страниц (нумерация страниц с 0). После этого следует логический адрес (в 16-ричной системе счисления).

Выход

Одно 16-ричное число - физический адрес, соответствующий логическому, или слово "error", если соответствующей страницы нет в таблице.

### G_pdp_rw

На одном Очень Секретном Заводе проблема - нужно заменить старую автоматическую линию по изготовлению и сборке Очень Секретного Изделия новой, авторы программ ушли на пенсию, а документацию съели мыши. Писать программы заново тоже очень непросто - вытаскивать знания из старых инженеров - значит опять нанимать программистов и терпеть убытки при отладке.

Отдел автоматизации предложил закупить новое оборудование с современными компьютерами внутри, на этих компьютерах (снабженцы еще разбираются, что там будет - очередной Windows или привычный Linux) написать программу - виртуальную машину старых компьютеров - и запускать старые программы в виртуальных машинах новых автоматов, чтобы работал старый, отлаженный код. Отделу автоматизации поручено написать эту программу - виртуальную машину старой автоматической линии. Вам от этой большой и нужной задачи достался маленький, но важный кусок: написать функции чтения и записи в байт и машинное слово.

Реализуемая архитектура:

Размер байта на старом и новом компьютере одинаковый: 8 бит.

1 машинное слово = 2 байта.

Байты и слова имеют единую сквозную нумерацию, то есть байты имеют адреса 0, 1, 2, 3, 4, 5, 6 и т.д, а слова, лежащие в этих байтах, 0, 2, 4, 6 и т.д.
little endian, т.е. байт с меньшим адресом лежит в младшем разряде.

Размер оперативной памяти 64 Кб (16-битные адреса). На самом деле, последние 8 Кб использовать для расположения программ и данных не будут, ибо там располагается часть, работающая с внешними устройствами: клавиатурой, монитором, сервомоторами и т.п.

Требуется на языке С:

Определить типы byte, word, adr для работы с байтами, машинными словами и адресами.

Определить глобальный массив mem, который будет "работать" оперативной памятью старой машины.

Реализовать функции чтения-записи в байт и слово (прототипы функций описаны ниже).

```c
byte b_read  (adr a);            // читает из "старой памяти" mem байт с "адресом" a.
void b_write (adr a, byte val);  // пишет значение val в "старую память" mem в байт с "адресом" a.
word w_read  (adr a);            // читает из "старой памяти" mem слово с "адресом" a.
void w_write (adr a, word val);  // пишет значение val в "старую память" mem в слово с "адресом" a.
```

Функцию main реализовывать не нужно.

### H_pdp_load

Реализуйте функцию `void load_file( )`, которая читает из стандартного потока ввода данные исполняемого файла в формате s-rec и записывает их в "память" старой машины с помощью функции `b_write`.

Исполняемый файл (s-rec файл) состоит из нескольких блоков. Каждый блок состоит из адреса начала блока adr, количества байтов данных в блоке n и байтов данных a1, a2 .. an (по одному байту на строку). Все числа шестнадцетиричные.

Реализуйте функцию `void mem_dump(adr start, word n)`, которая печатает на стандартный поток вывода n байт, начиная с адреса start в формате:
адрес слова в виде восьмеричного числа с ведущими нулями, двоеточие, содержимое слова в восьмеричном виде с ведущими нулями через пробел.

### I_G

Для написания анимации используется буфер следующего кадра в виде массива 1024x768 пикселей. Машина имеет кеш прямого отображения размером 16КБ. Используются переменные:

```c
struct pixel {
  char r;
  char g;
  char b;
  char a;
};

struct pixel buffer[1024][768];

register int i, j;
register char *cptr;
register int *iptr;
```

Предполагается, что:

- sizeof(char) = 1
- sizeof(int) = 4
- buffer начинается с адреса 0
- кеш изначально пуст
- в память обращаются только к buffer.Переменные i, j, cptr, и iptr хранятся в регистрах.

В половине случаев обращения к памяти наблюдаются промахи кэша.

```c
for (j=0; j < 768; j++) 
	for (i=0; i < 1024; i++){
        	buffer[i][j].r = 0;
	        buffer[i][j].g = 0;
	        buffer[i][j].b = 0;
	        buffer[i][j].a = 0;
    }
}
```

Какой размер кэш-линейки?